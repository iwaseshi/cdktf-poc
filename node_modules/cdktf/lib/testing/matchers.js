"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.toPlanSuccessfully = exports.toBeValidTerraform = exports.getToHaveProviderWithProperties = exports.getToHaveResourceWithProperties = exports.getToHaveDataSourceWithProperties = exports.asymetricDeepEqualIgnoringObjectCasing = exports.returnMatcherToJest = exports.AssertionReturn = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const fs = require("fs");
const path = require("path");
const child_process_1 = require("child_process");
const util_1 = require("../util");
/**
 * Class representing the contents of a return by an assertion
 */
class AssertionReturn {
    /**
     * Create an AssertionReturn
     * @param message - String message containing information about the result of the assertion
     * @param pass - Boolean pass denoting the success of the assertion
     */
    constructor(message, pass) {
        this.message = message;
        this.pass = pass;
    }
}
exports.AssertionReturn = AssertionReturn;
_a = JSII_RTTI_SYMBOL_1;
AssertionReturn[_a] = { fqn: "cdktf.testingMatchers.AssertionReturn", version: "0.14.3" };
/**
 * Reformats the contents of the base testing matcher return type AssertionReturn into type useable by jest
 * @param toReturn
 * @returns {MatcherReturnJest}
 */
function returnMatcherToJest(toReturn) {
    return {
        message: () => toReturn.message,
        pass: toReturn.pass,
    };
}
exports.returnMatcherToJest = returnMatcherToJest;
/**
 * Compares expected and received. All expected properties are matched and considered equal even if
 * there are more properties in the received object than in the expected object in which case it will still return true.
 * @param expected
 * @param received
 * @returns {boolean}
 */
function asymetricDeepEqualIgnoringObjectCasing(expected, received) {
    switch (typeof expected) {
        case "object":
            if (Array.isArray(expected)) {
                return (Array.isArray(received) &&
                    expected.length === received.length &&
                    expected.every((item, index) => asymetricDeepEqualIgnoringObjectCasing(item, received[index]) // recursively compare arrays
                    ));
            }
            if (expected === null && received === null) {
                return true;
            }
            if (expected === undefined && received === undefined) {
                return true;
            }
            if (expected === null || received === null) {
                return false;
            }
            // recursively compare objects and allow snake case as well as camel case
            return Object.keys(expected).every((key) => {
                if (received[key] !== undefined) {
                    return asymetricDeepEqualIgnoringObjectCasing(expected[key], received[key]);
                }
                if (received[util_1.snakeCase(key)] !== undefined) {
                    return asymetricDeepEqualIgnoringObjectCasing(expected[key], received[util_1.snakeCase(key)]);
                }
                return false;
            });
        default:
            return expected === received;
    }
}
exports.asymetricDeepEqualIgnoringObjectCasing = asymetricDeepEqualIgnoringObjectCasing;
const defaultPassEvaluation = (items, assertedProperties) => {
    return Object.values(items).some((item) => asymetricDeepEqualIgnoringObjectCasing(assertedProperties, item));
};
// eslint-disable-next-line jsdoc/require-jsdoc
function isAsymmetric(obj) {
    return !!obj && typeof obj === "object" && "asymmetricMatch" in obj;
}
// You can use expect.Anything(), expect.ObjectContaining, etc in jest, this makes it nicer to read
// when we print error messages
// eslint-disable-next-line jsdoc/require-jsdoc
function jestAsymetricMatcherStringifyReplacer(_key, value) {
    return isAsymmetric(value) ? `expect.${value.toString()}` : value;
}
// eslint-disable-next-line jsdoc/require-jsdoc
function getAssertElementWithProperties(
// We have the evaluation function configurable so we can make use of the specific testing frameworks capabilities
// This makes the resulting tests more native to the testing framework
customPassEvaluation) {
    const passEvaluation = customPassEvaluation || defaultPassEvaluation;
    return function getAssertElementWithProperties(type, received, itemType, properties = {}) {
        let stack;
        try {
            stack = JSON.parse(received);
        }
        catch (e) {
            throw new Error(`invalid JSON string passed: ${received}`);
        }
        const items = Object.values(Object.entries(stack[type] || {}) // for all data/resource entries
            .find(
        // find the object with a matching name
        ([type, _values]) => type === itemType.tfResourceType)?.[1] || {} // get all items of that type (encoded as a record of name -> config)
        ) || []; // get a list of all configs of that type
        const pass = passEvaluation(items, properties);
        if (pass) {
            return new AssertionReturn(`Expected no ${itemType.tfResourceType} with properties ${JSON.stringify(properties, jestAsymetricMatcherStringifyReplacer)} to be present in synthesized stack.
Found ${items.length === 0 ? "no" : items.length} ${itemType.tfResourceType} resources instead${items.length > 0 ? ":\n" + JSON.stringify(items, null, 2) : ""}`, pass);
        }
        else {
            return new AssertionReturn(`Expected ${itemType.tfResourceType} with properties ${JSON.stringify(properties, jestAsymetricMatcherStringifyReplacer)} to be present in synthesized stack.
Found ${items.length === 0 ? "no" : items.length} ${itemType.tfResourceType} resources instead${items.length > 0 ? ":\n" + JSON.stringify(items, null, 2) : ""}`, pass);
        }
    };
}
/**
 * Returns the function toHaveDataSourceWithProperties using the evaluation properties of customPassEvaluation
 * @param customPassEvaluation
 * @returns {getToHaveDataSourceWithProperties~toHaveDataSourceWithProperties}
 */
function getToHaveDataSourceWithProperties(customPassEvaluation) {
    /**
     * Evaluates the received stack to have the data source resourceType containing specified properties
     * @param received
     * @param resourceType
     * @param properties
     * @returns {AssertionReturn}
     */
    return function toHaveDataSourceWithProperties(received, resourceType, properties = {}) {
        return getAssertElementWithProperties(customPassEvaluation)("data", received, resourceType, properties);
    };
}
exports.getToHaveDataSourceWithProperties = getToHaveDataSourceWithProperties;
/**
 * Returns the function toHaveResourceWithProperties using the evaluation properties of customPassEvaluation
 * @param customPassEvaluation
 * @returns
 */
function getToHaveResourceWithProperties(customPassEvaluation) {
    /**
     * Evaluates the received stack to have the resource resourceType containing specified properties
     * @param received
     * @param resourceType
     * @param properties
     * @returns {AssertionReturn}
     */
    return function toHaveResourceWithProperties(received, resourceType, properties = {}) {
        return getAssertElementWithProperties(customPassEvaluation)("resource", received, resourceType, properties);
    };
}
exports.getToHaveResourceWithProperties = getToHaveResourceWithProperties;
/**
 * A helper util to verify wether an Error was caused by the Nodejs `process.spawn` API.
 *
 * @param   {Error}   err The Error object to verify
 * @returns {Boolean}     A bool indicating wether the input Error is containing process.spawn output.
 */
const isExecSpawnError = (err) => "output" in err &&
    Array.isArray(err.output) &&
    err.output.some((buf) => Buffer.isBuffer(buf));
/**
 * A helper util to append `process.spawn` output to assertion messages to improve developer expirience.
 *
 * @param   {String} message The message to optionally append process output to.
 * @param   {Error}  err     The error from which the `process.spawn` output should be retreived from.
 * @returns {String}         The finalized assertion message decorated with the `process.spawn` output.
 */
const withProcessOutput = (message, err) => {
    let output = "";
    if (isExecSpawnError(err)) {
        output =
            err.output
                ?.map((buffer) => buffer?.toString("utf8"))
                .filter(Boolean)
                .join("\n") ?? "";
    }
    const appendix = output.length ? `. Output: ${output}` : "";
    return `${message}: ${err}${appendix}.`;
};
/**
 * Returns the function toHaveProviderWithProperties using the evaluation properties of customPassEvaluation
 * @param customPassEvaluation
 * @returns {getToHaveProviderWithProperties~toHaveProviderWithProperties}
 */
function getToHaveProviderWithProperties(customPassEvaluation) {
    /**
     * Evaluates the received stack to have the provider resourceType containing specified properties
     * @param received
     * @param resourceType
     * @param properties
     * @returns {AssertionReturn}
     */
    return function toHaveProviderWithProperties(received, resourceType, properties = {}) {
        return getAssertElementWithProperties(customPassEvaluation)("provider", received, resourceType, properties);
    };
}
exports.getToHaveProviderWithProperties = getToHaveProviderWithProperties;
/**
 * Evaluates the validity of the received stack
 * @param received
 * @returns {AssertionReturn}
 */
function toBeValidTerraform(received) {
    try {
        if (!fs.statSync(received).isDirectory()) {
            throw new Error("Path is not a directory");
        }
    }
    catch (e) {
        return new AssertionReturn(`Expected subject to be a terraform directory: ${e}`, false);
    }
    try {
        const manifest = JSON.parse(fs.readFileSync(path.resolve(received, "manifest.json"), "utf8"));
        const stacks = Object.entries(manifest.stacks);
        stacks.forEach(([name, stack]) => {
            const opts = {
                cwd: path.resolve(received, stack.workingDirectory),
                env: process.env,
                stdio: "pipe",
            };
            child_process_1.execSync(`${util_1.terraformBinaryName} init`, opts);
            const out = child_process_1.execSync(`${util_1.terraformBinaryName} validate -json`, opts);
            const result = JSON.parse(out.toString());
            if (!result.valid) {
                throw new Error(`Found ${result.error_count} Errors in stack ${name}: ${result.diagnostics.join("\n")}`);
            }
        });
        return new AssertionReturn(`Expected subject not to be a valid terraform stack`, true);
    }
    catch (e) {
        return new AssertionReturn(withProcessOutput(`Expected subject to be a valid terraform stack`, e), false);
    }
}
exports.toBeValidTerraform = toBeValidTerraform;
/**
 * Evaluates the ability for the received stack to successfully plan
 * @param received
 * @returns {AssertionReturn}
 */
function toPlanSuccessfully(received) {
    try {
        if (!fs.statSync(received).isDirectory()) {
            throw new Error("Path is not a directory");
        }
    }
    catch (e) {
        return new AssertionReturn(`Expected subject to be a terraform directory: ${e}`, false);
    }
    try {
        const manifest = JSON.parse(fs.readFileSync(path.resolve(received, "manifest.json"), "utf8"));
        const stacks = Object.entries(manifest.stacks);
        stacks.forEach(([, stack]) => {
            const opts = {
                cwd: path.resolve(received, stack.workingDirectory),
                env: process.env,
                stdio: "ignore",
            };
            child_process_1.execSync(`${util_1.terraformBinaryName} init`, opts);
            // Throws on a non-zero exit code
            child_process_1.execSync(`${util_1.terraformBinaryName} plan -input=false -lock=false `, opts);
        });
        return new AssertionReturn(`Expected subject not to plan successfully`, true);
    }
    catch (e) {
        return new AssertionReturn(withProcessOutput(`Expected subject to plan successfully`, e), false);
    }
}
exports.toPlanSuccessfully = toPlanSuccessfully;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0Y2hlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJtYXRjaGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkMseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QixpREFBMkQ7QUFDM0Qsa0NBQXlEO0FBYXpEOztHQUVHO0FBQ0gsTUFBYSxlQUFlO0lBQzFCOzs7O09BSUc7SUFDSCxZQUE0QixPQUFlLEVBQWtCLElBQWE7UUFBOUMsWUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUFrQixTQUFJLEdBQUosSUFBSSxDQUFTO0lBQUcsQ0FBQzs7QUFOaEYsMENBT0M7OztBQUlEOzs7O0dBSUc7QUFDSCxTQUFnQixtQkFBbUIsQ0FDakMsUUFBeUI7SUFFekIsT0FBTztRQUNMLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsT0FBTztRQUMvQixJQUFJLEVBQUUsUUFBUSxDQUFDLElBQUk7S0FDcEIsQ0FBQztBQUNKLENBQUM7QUFQRCxrREFPQztBQUVEOzs7Ozs7R0FNRztBQUNILFNBQWdCLHNDQUFzQyxDQUNwRCxRQUFpQixFQUNqQixRQUFpQjtJQUVqQixRQUFRLE9BQU8sUUFBUSxFQUFFO1FBQ3ZCLEtBQUssUUFBUTtZQUNYLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRTtnQkFDM0IsT0FBTyxDQUNMLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDO29CQUN2QixRQUFRLENBQUMsTUFBTSxLQUFLLFFBQVEsQ0FBQyxNQUFNO29CQUNuQyxRQUFRLENBQUMsS0FBSyxDQUNaLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFLENBQ2Qsc0NBQXNDLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLDZCQUE2QjtxQkFDOUYsQ0FDRixDQUFDO2FBQ0g7WUFDRCxJQUFJLFFBQVEsS0FBSyxJQUFJLElBQUksUUFBUSxL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RSxDQUFDLENBQUMsRUFDN0QsS0FBSyxDQUNOLENBQUM7S0FDSDtBQUNILENBQUM7QUF6Q0QsZ0RBeUNDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBIYXNoaUNvcnAsIEluY1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1QTC0yLjBcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmc1wiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHsgZXhlY1N5bmMsIFNwYXduU3luY1JldHVybnMgfSBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiO1xuaW1wb3J0IHsgc25ha2VDYXNlLCB0ZXJyYWZvcm1CaW5hcnlOYW1lIH0gZnJvbSBcIi4uL3V0aWxcIjtcblxuLy8gVGVycmFmb3JtQ29uc3RydWN0b3IgaXMgY2xhc3Mgd2l0aCB0aGUgc3RhdGljIHByb3BlcnR5ICd0ZlJlc291cmNlVHlwZSdcbmV4cG9ydCBpbnRlcmZhY2UgVGVycmFmb3JtQ29uc3RydWN0b3Ige1xuICByZWFkb25seSB0ZlJlc291cmNlVHlwZTogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBTeW50aGVzaXplZFN0YWNrID0ge1xuICByZXNvdXJjZTogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgcHJvdmlkZXI6IFJlY29yZDxzdHJpbmcsIGFueT47XG59O1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyB0aGUgY29udGVudHMgb2YgYSByZXR1cm4gYnkgYW4gYXNzZXJ0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBBc3NlcnRpb25SZXR1cm4ge1xuICAvKipcbiAgICogQ3JlYXRlIGFuIEFzc2VydGlvblJldHVyblxuICAgKiBAcGFyYW0gbWVzc2FnZSAtIFN0cmluZyBtZXNzYWdlIGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlc3VsdCBvZiB0aGUgYXNzZXJ0aW9uXG4gICAqIEBwYXJhbSBwYXNzIC0gQm9vbGVhbiBwYXNzIGRlbm90aW5nIHRoZSBzdWNjZXNzIG9mIHRoZSBhc3NlcnRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBtZXNzYWdlOiBzdHJpbmcsIHB1YmxpYyByZWFkb25seSBwYXNzOiBib29sZWFuKSB7fVxufVxuXG5leHBvcnQgdHlwZSBNYXRjaGVyUmV0dXJuSmVzdCA9IHsgbWVzc2FnZTogKCkgPT4gc3RyaW5nOyBwYXNzOiBib29sZWFuIH07XG5cbi8qKlxuICogUmVmb3JtYXRzIHRoZSBjb250ZW50cyBvZiB0aGUgYmFzZSB0ZXN0aW5nIG1hdGNoZXIgcmV0dXJuIHR5cGUgQXNzZXJ0aW9uUmV0dXJuIGludG8gdHlwZSB1c2VhYmxlIGJ5IGplc3RcbiAqIEBwYXJhbSB0b1JldHVyblxuICogQHJldHVybnMge01hdGNoZXJSZXR1cm5KZXN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuTWF0Y2hlclRvSmVzdChcbiAgdG9SZXR1cm46IEFzc2VydGlvblJldHVyblxuKTogTWF0Y2hlclJldHVybkplc3Qge1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2U6ICgpID0+IHRvUmV0dXJuLm1lc3NhZ2UsXG4gICAgcGFzczogdG9SZXR1cm4ucGFzcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBDb21wYXJlcyBleHBlY3RlZCBhbmQgcmVjZWl2ZWQuIEFsbCBleHBlY3RlZCBwcm9wZXJ0aWVzIGFyZSBtYXRjaGVkIGFuZCBjb25zaWRlcmVkIGVxdWFsIGV2ZW4gaWZcbiAqIHRoZXJlIGFyZSBtb3JlIHByb3BlcnRpZXMgaW4gdGhlIHJlY2VpdmVkIG9iamVjdCB0aGFuIGluIHRoZSBleHBlY3RlZCBvYmplY3QgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIHN0aWxsIHJldHVybiB0cnVlLlxuICogQHBhcmFtIGV4cGVjdGVkXG4gKiBAcGFyYW0gcmVjZWl2ZWRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXN5bWV0cmljRGVlcEVxdWFsSWdub3JpbmdPYmplY3RDYXNpbmcoXG4gIGV4cGVjdGVkOiB1bmtub3duLFxuICByZWNlaXZlZDogdW5rbm93blxuKTogYm9vbGVhbiB7XG4gIHN3aXRjaCAodHlwZW9mIGV4cGVjdGVkKSB7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgQXJyYXkuaXNBcnJheShyZWNlaXZlZCkgJiZcbiAgICAgICAgICBleHBlY3RlZC5sZW5ndGggPT09IHJlY2VpdmVkLmxlbmd0aCAmJlxuICAgICAgICAgIGV4cGVjdGVkLmV2ZXJ5KFxuICAgICAgICAgICAgKGl0ZW0sIGluZGV4KSA9PlxuICAgICAgICAgICAgICBhc3ltZXRyaWNEZWVwRXF1YWxJZ25vcmluZ09iamVjdENhc2luZyhpdGVtLCByZWNlaXZlZFtpbmRleF0pIC8vIHJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGV4cGVjdGVkID09PSBudWxsICYmIHJlY2VpdmVkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGV4cGVjdGVkID09PSB1bmRlZmluZWQgJiYgcmVjZWl2ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChleHBlY3RlZCA9PT0gbnVsbCB8fCByZWNlaXZlZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYWxsb3cgc25ha2UgY2FzZSBhcyB3ZWxsIGFzIGNhbWVsIGNhc2VcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhleHBlY3RlZCBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikuZXZlcnkoKGtleSkgPT4ge1xuICAgICAgICBpZiAoKHJlY2VpdmVkIGFzIGFueSlba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGFzeW1ldHJpY0RlZXBFcXVhbElnbm9yaW5nT2JqZWN0Q2FzaW5nKFxuICAgICAgICAgICAgKGV4cGVjdGVkIGFzIGFueSlba2V5XSxcbiAgICAgICAgICAgIChyZWNlaXZlZCBhcyBhbnkpW2tleV1cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChyZWNlaXZlZCBhcyBhbnkpW3NuYWtlQ2FzZShrZXkpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGFzeW1ldHJpY0RlZXBFcXVhbElnbm9yaW5nT2JqZWN0Q2FzaW5nKFxuICAgICAgICAgICAgKGV4cGVjdGVkIGFzIGFueSlba2V5XSxcbiAgICAgICAgICAgIChyZWNlaXZlZCBhcyBhbnkpW3NuYWtlQ2FzZShrZXkpXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSByZWNlaXZlZDtcbiAgfVxufVxuY29uc3QgZGVmYXVsdFBhc3NFdmFsdWF0aW9uID0gKFxuICBpdGVtczogYW55LFxuICBhc3NlcnRlZFByb3BlcnRpZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbikgPT4ge1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpdGVtcykuc29tZSgoaXRlbTogYW55KSA9PlxuICAgIGFzeW1ldHJpY0RlZXBFcXVhbElnbm9yaW5nT2JqZWN0Q2FzaW5nKGFzc2VydGVkUHJvcGVydGllcywgaXRlbSlcbiAgKTtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5mdW5jdGlvbiBpc0FzeW1tZXRyaWMob2JqOiBhbnkpIHtcbiAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgXCJhc3ltbWV0cmljTWF0Y2hcIiBpbiBvYmo7XG59XG4vLyBZb3UgY2FuIHVzZSBleHBlY3QuQW55dGhpbmcoKSwgZXhwZWN0Lk9iamVjdENvbnRhaW5pbmcsIGV0YyBpbiBqZXN0LCB0aGlzIG1ha2VzIGl0IG5pY2VyIHRvIHJlYWRcbi8vIHdoZW4gd2UgcHJpbnQgZXJyb3IgbWVzc2FnZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5mdW5jdGlvbiBqZXN0QXN5bWV0cmljTWF0Y2hlclN0cmluZ2lmeVJlcGxhY2VyKF9rZXk6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICByZXR1cm4gaXNBc3ltbWV0cmljKHZhbHVlKSA/IGBleHBlY3QuJHt2YWx1ZS50b1N0cmluZygpfWAgOiB2YWx1ZTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5mdW5jdGlvbiBnZXRBc3NlcnRFbGVtZW50V2l0aFByb3BlcnRpZXMoXG4gIC8vIFdlIGhhdmUgdGhlIGV2YWx1YXRpb24gZnVuY3Rpb24gY29uZmlndXJhYmxlIHNvIHdlIGNhbiBtYWtlIHVzZSBvZiB0aGUgc3BlY2lmaWMgdGVzdGluZyBmcmFtZXdvcmtzIGNhcGFiaWxpdGllc1xuICAvLyBUaGlzIG1ha2VzIHRoZSByZXN1bHRpbmcgdGVzdHMgbW9yZSBuYXRpdmUgdG8gdGhlIHRlc3RpbmcgZnJhbWV3b3JrXG4gIGN1c3RvbVBhc3NFdmFsdWF0aW9uPzogKFxuICAgIGl0ZW1zOiBhbnlbXSwgLy8gY29uZmlndXJhdGlvbnMgb2YgdGhlIHJlcXVlc3RlZCB0eXBlXG4gICAgYXNzZXJ0ZWRQcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICkgPT4gYm9vbGVhblxuKSB7XG4gIGNvbnN0IHBhc3NFdmFsdWF0aW9uID0gY3VzdG9tUGFzc0V2YWx1YXRpb24gfHwgZGVmYXVsdFBhc3NFdmFsdWF0aW9uO1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0QXNzZXJ0RWxlbWVudFdpdGhQcm9wZXJ0aWVzKFxuICAgIHR5cGU6IGtleW9mIFN5bnRoZXNpemVkU3RhY2ssXG4gICAgcmVjZWl2ZWQ6IHN0cmluZyxcbiAgICBpdGVtVHlwZTogVGVycmFmb3JtQ29uc3RydWN0b3IsXG4gICAgcHJvcGVydGllczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9XG4gICk6IEFzc2VydGlvblJldHVybiB7XG4gICAgbGV0IHN0YWNrOiBTeW50aGVzaXplZFN0YWNrO1xuICAgIHRyeSB7XG4gICAgICBzdGFjayA9IEpTT04ucGFyc2UocmVjZWl2ZWQpIGFzIFN5bnRoZXNpemVkU3RhY2s7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIEpTT04gc3RyaW5nIHBhc3NlZDogJHtyZWNlaXZlZH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtcyA9XG4gICAgICBPYmplY3QudmFsdWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyhzdGFja1t0eXBlXSB8fCB7fSkgLy8gZm9yIGFsbCBkYXRhL3Jlc291cmNlIGVudHJpZXNcbiAgICAgICAgICAuZmluZChcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIG9iamVjdCB3aXRoIGEgbWF0Y2hpbmcgbmFtZVxuICAgICAgICAgICAgKFt0eXBlLCBfdmFsdWVzXSkgPT4gdHlwZSA9PT0gaXRlbVR5cGUudGZSZXNvdXJjZVR5cGVcbiAgICAgICAgICApPy5bMV0gfHwge30gLy8gZ2V0IGFsbCBpdGVtcyBvZiB0aGF0IHR5cGUgKGVuY29kZWQgYXMgYSByZWNvcmQgb2YgbmFtZSAtPiBjb25maWcpXG4gICAgICApIHx8IFtdOyAvLyBnZXQgYSBsaXN0IG9mIGFsbCBjb25maWdzIG9mIHRoYXQgdHlwZVxuICAgIGNvbnN0IHBhc3MgPSBwYXNzRXZhbHVhdGlvbihpdGVtcywgcHJvcGVydGllcyk7XG4gICAgaWYgKHBhc3MpIHtcbiAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uUmV0dXJuKFxuICAgICAgICBgRXhwZWN0ZWQgbm8gJHtcbiAgICAgICAgICBpdGVtVHlwZS50ZlJlc291cmNlVHlwZVxuICAgICAgICB9IHdpdGggcHJvcGVydGllcyAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgamVzdEFzeW1ldHJpY01hdGNoZXJTdHJpbmdpZnlSZXBsYWNlclxuICAgICAgICApfSB0byBiZSBwcmVzZW50IGluIHN5bnRoZXNpemVkIHN0YWNrLlxuRm91bmQgJHtpdGVtcy5sZW5ndGggPT09IDAgPyBcIm5vXCIgOiBpdGVtcy5sZW5ndGh9ICR7XG4gICAgICAgICAgaXRlbVR5cGUudGZSZXNvdXJjZVR5cGVcbiAgICAgICAgfSByZXNvdXJjZXMgaW5zdGVhZCR7XG4gICAgICAgICAgaXRlbXMubGVuZ3RoID4gMCA/IFwiOlxcblwiICsgSlNPTi5zdHJpbmdpZnkoaXRlbXMsIG51bGwsIDIpIDogXCJcIlxuICAgICAgICB9YCxcbiAgICAgICAgcGFzc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBBc3NlcnRpb25SZXR1cm4oXG4gICAgICAgIGBFeHBlY3RlZCAke2l0ZW1UeXBlLnRmUmVzb3VyY2VUeXBlfSB3aXRoIHByb3BlcnRpZXMgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgIGplc3RBc3ltZXRyaWNNYXRjaGVyU3RyaW5naWZ5UmVwbGFjZXJcbiAgICAgICAgKX0gdG8gYmUgcHJlc2VudCBpbiBzeW50aGVzaXplZCBzdGFjay5cbkZvdW5kICR7aXRlbXMubGVuZ3RoID09PSAwID8gXCJub1wiIDogaXRlbXMubGVuZ3RofSAke1xuICAgICAgICAgIGl0ZW1UeXBlLnRmUmVzb3VyY2VUeXBlXG4gICAgICAgIH0gcmVzb3VyY2VzIGluc3RlYWQke1xuICAgICAgICAgIGl0ZW1zLmxlbmd0aCA+IDAgPyBcIjpcXG5cIiArIEpTT04uc3RyaW5naWZ5KGl0ZW1zLCBudWxsLCAyKSA6IFwiXCJcbiAgICAgICAgfWAsXG4gICAgICAgIHBhc3NcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZ1bmN0aW9uIHRvSGF2ZURhdGFTb3VyY2VXaXRoUHJvcGVydGllcyB1c2luZyB0aGUgZXZhbHVhdGlvbiBwcm9wZXJ0aWVzIG9mIGN1c3RvbVBhc3NFdmFsdWF0aW9uXG4gKiBAcGFyYW0gY3VzdG9tUGFzc0V2YWx1YXRpb25cbiAqIEByZXR1cm5zIHtnZXRUb0hhdmVEYXRhU291cmNlV2l0aFByb3BlcnRpZXN+dG9IYXZlRGF0YVNvdXJjZVdpdGhQcm9wZXJ0aWVzfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9IYXZlRGF0YVNvdXJjZVdpdGhQcm9wZXJ0aWVzKFxuICBjdXN0b21QYXNzRXZhbHVhdGlvbj86IChcbiAgICBpdGVtczogYW55LFxuICAgIGFzc2VydGVkUHJvcGVydGllczogUmVjb3JkPHN0cmluZywgYW55PlxuICApID0+IGJvb2xlYW5cbikge1xuICAvKipcbiAgICogRXZhbHVhdGVzIHRoZSByZWNlaXZlZCBzdGFjayB0byBoYXZlIHRoZSBkYXRhIHNvdXJjZSByZXNvdXJjZVR5cGUgY29udGFpbmluZyBzcGVjaWZpZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gcmVjZWl2ZWRcbiAgICogQHBhcmFtIHJlc291cmNlVHlwZVxuICAgKiBAcGFyYW0gcHJvcGVydGllc1xuICAgKiBAcmV0dXJucyB7QXNzZXJ0aW9uUmV0dXJufVxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIHRvSGF2ZURhdGFTb3VyY2VXaXRoUHJvcGVydGllcyhcbiAgICByZWNlaXZlZDogc3RyaW5nLFxuICAgIHJlc291cmNlVHlwZTogVGVycmFmb3JtQ29uc3RydWN0b3IsXG4gICAgcHJvcGVydGllczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9XG4gICk6IEFzc2VydGlvblJldHVybiB7XG4gICAgcmV0dXJuIGdldEFzc2VydEVsZW1lbnRXaXRoUHJvcGVydGllcyhjdXN0b21QYXNzRXZhbHVhdGlvbikoXG4gICAgICBcImRhdGFcIixcbiAgICAgIHJlY2VpdmVkLFxuICAgICAgcmVzb3VyY2VUeXBlLFxuICAgICAgcHJvcGVydGllc1xuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZnVuY3Rpb24gdG9IYXZlUmVzb3VyY2VXaXRoUHJvcGVydGllcyB1c2luZyB0aGUgZXZhbHVhdGlvbiBwcm9wZXJ0aWVzIG9mIGN1c3RvbVBhc3NFdmFsdWF0aW9uXG4gKiBAcGFyYW0gY3VzdG9tUGFzc0V2YWx1YXRpb25cbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb0hhdmVSZXNvdXJjZVdpdGhQcm9wZXJ0aWVzKFxuICBjdXN0b21QYXNzRXZhbHVhdGlvbj86IChcbiAgICBpdGVtczogYW55LFxuICAgIGFzc2VydGVkUHJvcGVydGllczogUmVjb3JkPHN0cmluZywgYW55PlxuICApID0+IGJvb2xlYW5cbikge1xuICAvKipcbiAgICogRXZhbHVhdGVzIHRoZSByZWNlaXZlZCBzdGFjayB0byBoYXZlIHRoZSByZXNvdXJjZSByZXNvdXJjZVR5cGUgY29udGFpbmluZyBzcGVjaWZpZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gcmVjZWl2ZWRcbiAgICogQHBhcmFtIHJlc291cmNlVHlwZVxuICAgKiBAcGFyYW0gcHJvcGVydGllc1xuICAgKiBAcmV0dXJucyB7QXNzZXJ0aW9uUmV0dXJufVxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIHRvSGF2ZVJlc291cmNlV2l0aFByb3BlcnRpZXMoXG4gICAgcmVjZWl2ZWQ6IHN0cmluZyxcbiAgICByZXNvdXJjZVR5cGU6IFRlcnJhZm9ybUNvbnN0cnVjdG9yLFxuICAgIHByb3BlcnRpZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fVxuICApOiBBc3NlcnRpb25SZXR1cm4ge1xuICAgIHJldHVybiBnZXRBc3NlcnRFbGVtZW50V2l0aFByb3BlcnRpZXMoY3VzdG9tUGFzc0V2YWx1YXRpb24pKFxuICAgICAgXCJyZXNvdXJjZVwiLFxuICAgICAgcmVjZWl2ZWQsXG4gICAgICByZXNvdXJjZVR5cGUsXG4gICAgICBwcm9wZXJ0aWVzXG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIGhlbHBlciB1dGlsIHRvIHZlcmlmeSB3ZXRoZXIgYW4gRXJyb3Igd2FzIGNhdXNlZCBieSB0aGUgTm9kZWpzIGBwcm9jZXNzLnNwYXduYCBBUEkuXG4gKlxuICogQHBhcmFtICAge0Vycm9yfSAgIGVyciBUaGUgRXJyb3Igb2JqZWN0IHRvIHZlcmlmeVxuICogQHJldHVybnMge0Jvb2xlYW59ICAgICBBIGJvb2wgaW5kaWNhdGluZyB3ZXRoZXIgdGhlIGlucHV0IEVycm9yIGlzIGNvbnRhaW5pbmcgcHJvY2Vzcy5zcGF3biBvdXRwdXQuXG4gKi9cbmNvbnN0IGlzRXhlY1NwYXduRXJyb3IgPSAoZXJyOiBhbnkpOiBlcnIgaXMgRXJyb3IgJiBTcGF3blN5bmNSZXR1cm5zPGFueT4gPT5cbiAgXCJvdXRwdXRcIiBpbiBlcnIgJiZcbiAgQXJyYXkuaXNBcnJheShlcnIub3V0cHV0KSAmJlxuICBlcnIub3V0cHV0LnNvbWUoKGJ1ZjogYW55KSA9PiBCdWZmZXIuaXNCdWZmZXIoYnVmKSk7XG5cbi8qKlxuICogQSBoZWxwZXIgdXRpbCB0byBhcHBlbmQgYHByb2Nlc3Muc3Bhd25gIG91dHB1dCB0byBhc3NlcnRpb24gbWVzc2FnZXMgdG8gaW1wcm92ZSBkZXZlbG9wZXIgZXhwaXJpZW5jZS5cbiAqXG4gKiBAcGFyYW0gICB7U3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIG9wdGlvbmFsbHkgYXBwZW5kIHByb2Nlc3Mgb3V0cHV0IHRvLlxuICogQHBhcmFtICAge0Vycm9yfSAgZXJyICAgICBUaGUgZXJyb3IgZnJvbSB3aGljaCB0aGUgYHByb2Nlc3Muc3Bhd25gIG91dHB1dCBzaG91bGQgYmUgcmV0cmVpdmVkIGZyb20uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSAgICAgICAgIFRoZSBmaW5hbGl6ZWQgYXNzZXJ0aW9uIG1lc3NhZ2UgZGVjb3JhdGVkIHdpdGggdGhlIGBwcm9jZXNzLnNwYXduYCBvdXRwdXQuXG4gKi9cbmNvbnN0IHdpdGhQcm9jZXNzT3V0cHV0ID0gKG1lc3NhZ2U6IHN0cmluZywgZXJyOiB1bmtub3duKSA9PiB7XG4gIGxldCBvdXRwdXQgPSBcIlwiO1xuXG4gIGlmIChpc0V4ZWNTcGF3bkVycm9yKGVycikpIHtcbiAgICBvdXRwdXQgPVxuICAgICAgZXJyLm91dHB1dFxuICAgICAgICA/Lm1hcCgoYnVmZmVyOiBCdWZmZXIpID0+IGJ1ZmZlcj8udG9TdHJpbmcoXCJ1dGY4XCIpKVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgIC5qb2luKFwiXFxuXCIpID8/IFwiXCI7XG4gIH1cblxuICBjb25zdCBhcHBlbmRpeCA9IG91dHB1dC5sZW5ndGggPyBgLiBPdXRwdXQ6ICR7b3V0cHV0fWAgOiBcIlwiO1xuXG4gIHJldHVybiBgJHttZXNzYWdlfTogJHtlcnJ9JHthcHBlbmRpeH0uYDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZnVuY3Rpb24gdG9IYXZlUHJvdmlkZXJXaXRoUHJvcGVydGllcyB1c2luZyB0aGUgZXZhbHVhdGlvbiBwcm9wZXJ0aWVzIG9mIGN1c3RvbVBhc3NFdmFsdWF0aW9uXG4gKiBAcGFyYW0gY3VzdG9tUGFzc0V2YWx1YXRpb25cbiAqIEByZXR1cm5zIHtnZXRUb0hhdmVQcm92aWRlcldpdGhQcm9wZXJ0aWVzfnRvSGF2ZVByb3ZpZGVyV2l0aFByb3BlcnRpZXN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb0hhdmVQcm92aWRlcldpdGhQcm9wZXJ0aWVzKFxuICBjdXN0b21QYXNzRXZhbHVhdGlvbj86IChcbiAgICBpdGVtczogYW55LFxuICAgIGFzc2VydGVkUHJvcGVydGllczogUmVjb3JkPHN0cmluZywgYW55PlxuICApID0+IGJvb2xlYW5cbikge1xuICAvKipcbiAgICogRXZhbHVhdGVzIHRoZSByZWNlaXZlZCBzdGFjayB0byBoYXZlIHRoZSBwcm92aWRlciByZXNvdXJjZVR5cGUgY29udGFpbmluZyBzcGVjaWZpZWQgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gcmVjZWl2ZWRcbiAgICogQHBhcmFtIHJlc291cmNlVHlwZVxuICAgKiBAcGFyYW0gcHJvcGVydGllc1xuICAgKiBAcmV0dXJucyB7QXNzZXJ0aW9uUmV0dXJufVxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIHRvSGF2ZVByb3ZpZGVyV2l0aFByb3BlcnRpZXMoXG4gICAgcmVjZWl2ZWQ6IHN0cmluZyxcbiAgICByZXNvdXJjZVR5cGU6IFRlcnJhZm9ybUNvbnN0cnVjdG9yLFxuICAgIHByb3BlcnRpZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fVxuICApOiBBc3NlcnRpb25SZXR1cm4ge1xuICAgIHJldHVybiBnZXRBc3NlcnRFbGVtZW50V2l0aFByb3BlcnRpZXMoY3VzdG9tUGFzc0V2YWx1YXRpb24pKFxuICAgICAgXCJwcm92aWRlclwiLFxuICAgICAgcmVjZWl2ZWQsXG4gICAgICByZXNvdXJjZVR5cGUsXG4gICAgICBwcm9wZXJ0aWVzXG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBFdmFsdWF0ZXMgdGhlIHZhbGlkaXR5IG9mIHRoZSByZWNlaXZlZCBzdGFja1xuICogQHBhcmFtIHJlY2VpdmVkXG4gKiBAcmV0dXJucyB7QXNzZXJ0aW9uUmV0dXJufVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CZVZhbGlkVGVycmFmb3JtKHJlY2VpdmVkOiBzdHJpbmcpOiBBc3NlcnRpb25SZXR1cm4ge1xuICB0cnkge1xuICAgIGlmICghZnMuc3RhdFN5bmMocmVjZWl2ZWQpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhdGggaXMgbm90IGEgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uUmV0dXJuKFxuICAgICAgYEV4cGVjdGVkIHN1YmplY3QgdG8gYmUgYSB0ZXJyYWZvcm0gZGlyZWN0b3J5OiAke2V9YCxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgbWFuaWZlc3QgPSBKU09OLnBhcnNlKFxuICAgICAgZnMucmVhZEZpbGVTeW5jKHBhdGgucmVzb2x2ZShyZWNlaXZlZCwgXCJtYW5pZmVzdC5qc29uXCIpLCBcInV0ZjhcIilcbiAgICApO1xuXG4gICAgY29uc3Qgc3RhY2tzID0gT2JqZWN0LmVudHJpZXMobWFuaWZlc3Quc3RhY2tzKTtcblxuICAgIHN0YWNrcy5mb3JFYWNoKChbbmFtZSwgc3RhY2tdKSA9PiB7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICBjd2Q6IHBhdGgucmVzb2x2ZShyZWNlaXZlZCwgKHN0YWNrIGFzIGFueSkud29ya2luZ0RpcmVjdG9yeSksXG4gICAgICAgIGVudjogcHJvY2Vzcy5lbnYsXG4gICAgICAgIHN0ZGlvOiBcInBpcGVcIixcbiAgICAgIH0gYXMgYW55O1xuICAgICAgZXhlY1N5bmMoYCR7dGVycmFmb3JtQmluYXJ5TmFtZX0gaW5pdGAsIG9wdHMpO1xuICAgICAgY29uc3Qgb3V0ID0gZXhlY1N5bmMoYCR7dGVycmFmb3JtQmluYXJ5TmFtZX0gdmFsaWRhdGUgLWpzb25gLCBvcHRzKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXQudG9TdHJpbmcoKSk7XG4gICAgICBpZiAoIXJlc3VsdC52YWxpZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZvdW5kICR7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3JfY291bnRcbiAgICAgICAgICB9IEVycm9ycyBpbiBzdGFjayAke25hbWV9OiAke3Jlc3VsdC5kaWFnbm9zdGljcy5qb2luKFwiXFxuXCIpfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEFzc2VydGlvblJldHVybihcbiAgICAgIGBFeHBlY3RlZCBzdWJqZWN0IG5vdCB0byBiZSBhIHZhbGlkIHRlcnJhZm9ybSBzdGFja2AsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uUmV0dXJuKFxuICAgICAgd2l0aFByb2Nlc3NPdXRwdXQoYEV4cGVjdGVkIHN1YmplY3QgdG8gYmUgYSB2YWxpZCB0ZXJyYWZvcm0gc3RhY2tgLCBlKSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEV2YWx1YXRlcyB0aGUgYWJpbGl0eSBmb3IgdGhlIHJlY2VpdmVkIHN0YWNrIHRvIHN1Y2Nlc3NmdWxseSBwbGFuXG4gKiBAcGFyYW0gcmVjZWl2ZWRcbiAqIEByZXR1cm5zIHtBc3NlcnRpb25SZXR1cm59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1BsYW5TdWNjZXNzZnVsbHkocmVjZWl2ZWQ6IHN0cmluZyk6IEFzc2VydGlvblJldHVybiB7XG4gIHRyeSB7XG4gICAgaWYgKCFmcy5zdGF0U3luYyhyZWNlaXZlZCkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0aCBpcyBub3QgYSBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG5ldyBBc3NlcnRpb25SZXR1cm4oXG4gICAgICBgRXhwZWN0ZWQgc3ViamVjdCB0byBiZSBhIHRlcnJhZm9ybSBkaXJlY3Rvcnk6ICR7ZX1gLFxuICAgICAgZmFsc2VcbiAgICApO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBtYW5pZmVzdCA9IEpTT04ucGFyc2UoXG4gICAgICBmcy5yZWFkRmlsZVN5bmMocGF0aC5yZXNvbHZlKHJlY2VpdmVkLCBcIm1hbmlmZXN0Lmpzb25cIiksIFwidXRmOFwiKVxuICAgICk7XG5cbiAgICBjb25zdCBzdGFja3MgPSBPYmplY3QuZW50cmllcyhtYW5pZmVzdC5zdGFja3MpO1xuXG4gICAgc3RhY2tzLmZvckVhY2goKFssIHN0YWNrXSkgPT4ge1xuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgY3dkOiBwYXRoLnJlc29sdmUocmVjZWl2ZWQsIChzdGFjayBhcyBhbnkpLndvcmtpbmdEaXJlY3RvcnkpLFxuICAgICAgICBlbnY6IHByb2Nlc3MuZW52LFxuICAgICAgICBzdGRpbzogXCJpZ25vcmVcIixcbiAgICAgIH0gYXMgYW55O1xuICAgICAgZXhlY1N5bmMoYCR7dGVycmFmb3JtQmluYXJ5TmFtZX0gaW5pdGAsIG9wdHMpO1xuXG4gICAgICAvLyBUaHJvd3Mgb24gYSBub24temVybyBleGl0IGNvZGVcbiAgICAgIGV4ZWNTeW5jKGAke3RlcnJhZm9ybUJpbmFyeU5hbWV9IHBsYW4gLWlucHV0PWZhbHNlIC1sb2NrPWZhbHNlIGAsIG9wdHMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBBc3NlcnRpb25SZXR1cm4oXG4gICAgICBgRXhwZWN0ZWQgc3ViamVjdCBub3QgdG8gcGxhbiBzdWNjZXNzZnVsbHlgLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbmV3IEFzc2VydGlvblJldHVybihcbiAgICAgIHdpdGhQcm9jZXNzT3V0cHV0KGBFeHBlY3RlZCBzdWJqZWN0IHRvIHBsYW4gc3VjY2Vzc2Z1bGx5YCwgZSksXG4gICAgICBmYWxzZVxuICAgICk7XG4gIH1cbn1cbiJdfQ==
"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TerraformElement = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const assert_1 = require("assert");
const constructs_1 = require("constructs");
const _1 = require(".");
const terraform_stack_1 = require("./terraform-stack");
const tfExpression_1 = require("./tfExpression");
const TERRAFORM_ELEMENT_SYMBOL = Symbol.for("cdktf/TerraformElement");
// eslint-disable-next-line jsdoc/require-jsdoc
class TerraformElement extends constructs_1.Construct {
    constructor(scope, id, elementType) {
        super(scope, id);
        this.rawOverrides = {};
        Object.defineProperty(this, TERRAFORM_ELEMENT_SYMBOL, { value: true });
        this._elementType = elementType;
        if (_1.Token.isUnresolved(id)) {
            throw new Error("You cannot use a Token (e.g. a reference to an attribute) as the id of a construct");
        }
        this.node.addMetadata("stacktrace", "trace");
    }
    get cdktfStack() {
        return terraform_stack_1.TerraformStack.of(this);
    }
    static isTerraformElement(x) {
        return x !== null && typeof x === "object" && TERRAFORM_ELEMENT_SYMBOL in x;
    }
    toTerraform() {
        return {};
    }
    toMetadata() {
        return {};
    }
    get fqn() {
        if (!this._fqnToken) {
            assert_1.ok(!!this._elementType, "Element type not set");
            this._fqnToken = _1.Token.asString(tfExpression_1.ref(`${this._elementType}.${this.friendlyUniqueId}`, this.cdktfStack));
        }
        return this._fqnToken;
    }
    get friendlyUniqueId() {
        if (!this._friendlyUniqueId) {
            if (this._logicalIdOverride) {
                this._friendlyUniqueId = this._logicalIdOverride;
            }
            else {
                this._friendlyUniqueId = this.cdktfStack.getLogicalId(this);
            }
        }
        return this._friendlyUniqueId;
    }
    /**
     * Overrides the auto-generated logical ID with a specific ID.
     * @param newLogicalId The new logical ID to use for this stack element.
     */
    overrideLogicalId(newLogicalId) {
        assert_1.ok(!this._fqnToken, "Logical ID may not be overriden once .fqn has been requested. Make sure to override the id before passing the construct to other constructs.");
        this._logicalIdOverride = newLogicalId;
    }
    /**
     * Resets a previously passed logical Id to use the auto-generated logical id again
     */
    resetOverrideLogicalId() {
        assert_1.ok(!this._fqnToken, "Logical ID may not be overriden once .fqn has been requested. You can only reset the override before you pass the construct to other constructs.");
        this._logicalIdOverride = undefined;
    }
    addOverride(path, value) {
        const parts = path.split(".");
        let curr = this.rawOverrides;
        while (parts.length > 1) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const key = parts.shift();
            // if we can't recurse further or the previous value is not an
            // object overwrite it with an object.
            const isObject = curr[key] != null &&
                typeof curr[key] === "object" &&
                !Array.isArray(curr[key]);
            if (!isObject) {
                curr[key] = {};
            }
            curr = curr[key];
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const lastKey = parts.shift();
        curr[lastKey] = value;
    }
    get constructNodeMetadata() {
        return {
            metadata: {
                path: this.node.path,
                uniqueId: this.friendlyUniqueId,
                stackTrace: this.node.metadata.find((e) => e.type === "stacktrace")
                    ?.trace,
            },
        };
    }
}
exports.TerraformElement = TerraformElement;
_a = JSII_RTTI_SYMBOL_1;
TerraformElement[_a] = { fqn: "cdktf.TerraformElement", version: "0.14.3" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVycmFmb3JtLWVsZW1lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ0ZXJyYWZvcm0tZWxlbWVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkMsbUNBQTRCO0FBQzVCLDJDQUF1QztBQUN2Qyx3QkFBMEI7QUFDMUIsdURBQW1EO0FBQ25ELGlEQUFxQztBQUVyQyxNQUFNLHdCQUF3QixHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsd0JBQXdCLENBQUMsQ0FBQztBQVF0RSwrQ0FBK0M7QUFDL0MsTUFBYSxnQkFBaUIsU0FBUSxzQkFBUztJQWdCN0MsWUFBWSxLQUFnQixFQUFFLEVBQVUsRUFBRSxXQUFvQjtRQUM1RCxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBaEJBLGlCQUFZLEdBQVEsRUFBRSxDQUFDO1FBaUJ4QyxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSx3QkFBd0IsRUFBRSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZFLElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO1FBRWhDLElBQUksUUFBSyxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsRUFBRTtZQUMxQixNQUFNLElBQUksS0FBSyxDQUNiLG9GQUFvRixDQUNyRixDQUFDO1NBQ0g7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVELElBQVcsVUFBVTtRQUNuQixPQUFPLGdDQUFjLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFTSxNQUFNLENBQUMsa0JBQWtCLENBQUMsQ0FBTTtRQUNyQyxPQUFPLENBQUMsS0FBSyxJQUFJLElBQUksT0FBTyxDQUFDLEtBQUssUUFBUSxJQUFJLHdCQUF3QixJQUFJLENBQUMsQ0FBQztJQUM5RSxDQUFD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QkFDakUsRUFBRSxLQUFLO2FBQ2tCO1NBQzlCLENBQUM7SUFDSixDQUFDOztBQWpJSCw0Q0FrSUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIEhhc2hpQ29ycCwgSW5jXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTVBMLTIuMFxuaW1wb3J0IHsgb2sgfSBmcm9tIFwiYXNzZXJ0XCI7XG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tIFwiY29uc3RydWN0c1wiO1xuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLlwiO1xuaW1wb3J0IHsgVGVycmFmb3JtU3RhY2sgfSBmcm9tIFwiLi90ZXJyYWZvcm0tc3RhY2tcIjtcbmltcG9ydCB7IHJlZiB9IGZyb20gXCIuL3RmRXhwcmVzc2lvblwiO1xuXG5jb25zdCBURVJSQUZPUk1fRUxFTUVOVF9TWU1CT0wgPSBTeW1ib2wuZm9yKFwiY2RrdGYvVGVycmFmb3JtRWxlbWVudFwiKTtcblxuZXhwb3J0IGludGVyZmFjZSBUZXJyYWZvcm1FbGVtZW50TWV0YWRhdGEge1xuICByZWFkb25seSBwYXRoOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHVuaXF1ZUlkOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHN0YWNrVHJhY2U6IHN0cmluZ1tdO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGNsYXNzIFRlcnJhZm9ybUVsZW1lbnQgZXh0ZW5kcyBDb25zdHJ1Y3Qge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgcmF3T3ZlcnJpZGVzOiBhbnkgPSB7fTtcblxuICAvKipcbiAgICogQW4gZXhwbGljaXQgbG9naWNhbCBJRCBwcm92aWRlZCBieSBgb3ZlcnJpZGVMb2dpY2FsSWRgLlxuICAgKi9cbiAgcHJpdmF0ZSBfbG9naWNhbElkT3ZlcnJpZGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFR5cGUgb2YgdGhpcyBlbGVtZW50LCB1c2VkIGZvciBmcW4uXG4gICAqIFRoaXMgaXMgdW5kZWZpbmVkIGZvclxuICAgKiAtIGVsZW1lbnRzIG5vdCByZWZlcmFibGUsIGxpa2UgVGVycmFmb3JtT3V0cHV0XG4gICAqIC0gZWxlbWVudHMgdXNpbmcgdGhlaXIgb3duIGZxbiBpbXBsZW1lbnRhdGlvbiwgbGlrZSBUZXJyYWZvcm1Qcm92aWRlclxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBfZWxlbWVudFR5cGU/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgZWxlbWVudFR5cGU/OiBzdHJpbmcpIHtcbiAgICBzdXBlcihzY29wZSwgaWQpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBURVJSQUZPUk1fRUxFTUVOVF9TWU1CT0wsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgdGhpcy5fZWxlbWVudFR5cGUgPSBlbGVtZW50VHlwZTtcblxuICAgIGlmIChUb2tlbi5pc1VucmVzb2x2ZWQoaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiWW91IGNhbm5vdCB1c2UgYSBUb2tlbiAoZS5nLiBhIHJlZmVyZW5jZSB0byBhbiBhdHRyaWJ1dGUpIGFzIHRoZSBpZCBvZiBhIGNvbnN0cnVjdFwiXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMubm9kZS5hZGRNZXRhZGF0YShcInN0YWNrdHJhY2VcIiwgXCJ0cmFjZVwiKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgY2RrdGZTdGFjaygpOiBUZXJyYWZvcm1TdGFjayB7XG4gICAgcmV0dXJuIFRlcnJhZm9ybVN0YWNrLm9mKHRoaXMpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpc1RlcnJhZm9ybUVsZW1lbnQoeDogYW55KTogeCBpcyBUZXJyYWZvcm1FbGVtZW50IHtcbiAgICByZXR1cm4geCAhPT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiBURVJSQUZPUk1fRUxFTUVOVF9TWU1CT0wgaW4geDtcbiAgfVxuXG4gIHB1YmxpYyB0b1RlcnJhZm9ybSgpOiBhbnkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHB1YmxpYyB0b01ldGFkYXRhKCk6IGFueSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgcHJpdmF0ZSBfZnFuVG9rZW4/OiBzdHJpbmc7XG5cbiAgcHVibGljIGdldCBmcW4oKSB7XG4gICAgaWYgKCF0aGlzLl9mcW5Ub2tlbikge1xuICAgICAgb2soISF0aGlzLl9lbGVtZW50VHlwZSwgXCJFbGVtZW50IHR5cGUgbm90IHNldFwiKTtcbiAgICAgIHRoaXMuX2ZxblRva2VuID0gVG9rZW4uYXNTdHJpbmcoXG4gICAgICAgIHJlZihgJHt0aGlzLl9lbGVtZW50VHlwZX0uJHt0aGlzLmZyaWVuZGx5VW5pcXVlSWR9YCwgdGhpcy5jZGt0ZlN0YWNrKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZxblRva2VuO1xuICB9XG5cbiAgcHJpdmF0ZSBfZnJpZW5kbHlVbmlxdWVJZD86IHN0cmluZztcblxuICBwdWJsaWMgZ2V0IGZyaWVuZGx5VW5pcXVlSWQoKSB7XG4gICAgaWYgKCF0aGlzLl9mcmllbmRseVVuaXF1ZUlkKSB7XG4gICAgICBpZiAodGhpcy5fbG9naWNhbElkT3ZlcnJpZGUpIHtcbiAgICAgICAgdGhpcy5fZnJpZW5kbHlVbmlxdWVJZCA9IHRoaXMuX2xvZ2ljYWxJZE92ZXJyaWRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZnJpZW5kbHlVbmlxdWVJZCA9IHRoaXMuY2RrdGZTdGFjay5nZXRMb2dpY2FsSWQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9mcmllbmRseVVuaXF1ZUlkO1xuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyB0aGUgYXV0by1nZW5lcmF0ZWQgbG9naWNhbCBJRCB3aXRoIGEgc3BlY2lmaWMgSUQuXG4gICAqIEBwYXJhbSBuZXdMb2dpY2FsSWQgVGhlIG5ldyBsb2dpY2FsIElEIHRvIHVzZSBmb3IgdGhpcyBzdGFjayBlbGVtZW50LlxuICAgKi9cbiAgcHVibGljIG92ZXJyaWRlTG9naWNhbElkKG5ld0xvZ2ljYWxJZDogc3RyaW5nKSB7XG4gICAgb2soXG4gICAgICAhdGhpcy5fZnFuVG9rZW4sXG4gICAgICBcIkxvZ2ljYWwgSUQgbWF5IG5vdCBiZSBvdmVycmlkZW4gb25jZSAuZnFuIGhhcyBiZWVuIHJlcXVlc3RlZC4gTWFrZSBzdXJlIHRvIG92ZXJyaWRlIHRoZSBpZCBiZWZvcmUgcGFzc2luZyB0aGUgY29uc3RydWN0IHRvIG90aGVyIGNvbnN0cnVjdHMuXCJcbiAgICApO1xuICAgIHRoaXMuX2xvZ2ljYWxJZE92ZXJyaWRlID0gbmV3TG9naWNhbElkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyBhIHByZXZpb3VzbHkgcGFzc2VkIGxvZ2ljYWwgSWQgdG8gdXNlIHRoZSBhdXRvLWdlbmVyYXRlZCBsb2dpY2FsIGlkIGFnYWluXG4gICAqL1xuICBwdWJsaWMgcmVzZXRPdmVycmlkZUxvZ2ljYWxJZCgpIHtcbiAgICBvayhcbiAgICAgICF0aGlzLl9mcW5Ub2tlbixcbiAgICAgIFwiTG9naWNhbCBJRCBtYXkgbm90IGJlIG92ZXJyaWRlbiBvbmNlIC5mcW4gaGFzIGJlZW4gcmVxdWVzdGVkLiBZb3UgY2FuIG9ubHkgcmVzZXQgdGhlIG92ZXJyaWRlIGJlZm9yZSB5b3UgcGFzcyB0aGUgY29uc3RydWN0IHRvIG90aGVyIGNvbnN0cnVjdHMuXCJcbiAgICApO1xuICAgIHRoaXMuX2xvZ2ljYWxJZE92ZXJyaWRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHVibGljIGFkZE92ZXJyaWRlKHBhdGg6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdChcIi5cIik7XG4gICAgbGV0IGN1cnI6IGFueSA9IHRoaXMucmF3T3ZlcnJpZGVzO1xuXG4gICAgd2hpbGUgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICBjb25zdCBrZXkgPSBwYXJ0cy5zaGlmdCgpITtcblxuICAgICAgLy8gaWYgd2UgY2FuJ3QgcmVjdXJzZSBmdXJ0aGVyIG9yIHRoZSBwcmV2aW91cyB2YWx1ZSBpcyBub3QgYW5cbiAgICAgIC8vIG9iamVjdCBvdmVyd3JpdGUgaXQgd2l0aCBhbiBvYmplY3QuXG4gICAgICBjb25zdCBpc09iamVjdCA9XG4gICAgICAgIGN1cnJba2V5XSAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBjdXJyW2tleV0gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgIUFycmF5LmlzQXJyYXkoY3VycltrZXldKTtcbiAgICAgIGlmICghaXNPYmplY3QpIHtcbiAgICAgICAgY3VycltrZXldID0ge307XG4gICAgICB9XG5cbiAgICAgIGN1cnIgPSBjdXJyW2tleV07XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICBjb25zdCBsYXN0S2V5ID0gcGFydHMuc2hpZnQoKSE7XG4gICAgY3VycltsYXN0S2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldCBjb25zdHJ1Y3ROb2RlTWV0YWRhdGEoKTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIHBhdGg6IHRoaXMubm9kZS5wYXRoLFxuICAgICAgICB1bmlxdWVJZDogdGhpcy5mcmllbmRseVVuaXF1ZUlkLFxuICAgICAgICBzdGFja1RyYWNlOiB0aGlzLm5vZGUubWV0YWRhdGEuZmluZCgoZSkgPT4gZS50eXBlID09PSBcInN0YWNrdHJhY2VcIilcbiAgICAgICAgICA/LnRyYWNlLFxuICAgICAgfSBhcyBUZXJyYWZvcm1FbGVtZW50TWV0YWRhdGEsXG4gICAgfTtcbiAgfVxufVxuIl19